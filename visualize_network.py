#!/usr/bin/env python3
"""
visualize_network_dynamic.py

An dynamic visualization tool for neural network parameters.
This script reads "network_parameters.csv" generated by C++ simulation
and displays:
  - Actor and Critic neural network diagrams 
  - Actor output metrics (raw outputs, softmax policy, chosen action, and entropy),
  - Critic output and learning metrics (critic value, reward, TD error, advantage).

Usage:
  python3 visualize_network_dynamic.py
"""

import csv
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from matplotlib import gridspec

# --- Network dimensions (should match your C++ definitions) ---
NUM_INPUTS    = 36      # e.g. sensor rays + state values (shared by both networks)
HIDDEN_SIZE   = 64
ACTOR_OUTPUTS = 4       # discrete outputs for actor network
CRITIC_OUTPUTS = 1      # single value for critic network

# --- CSV Reading: Group data by category ---
def read_csv_data(filename):
    """
    Reads the CSV file and returns a dictionary with keys for each category.
    For categories with indices (e.g., "Input", "Actor_z1", etc.), stores values in a dict.
    For singular categories (with no indices), stores the value directly.
    """
    data = {}
    # List of all known categories from serializer:
    categories = ["Input", "Actor_z1", "Actor_h1", "Actor_z2", "Policy",
                  "Chosen_Action", "Entropy",
                  "Critic_z1", "Critic_h1", "Critic_Value",
                  "Reward", "TD_Error", "Advantage",
                  "actor_W1", "actor_b1", "actor_W2", "actor_b2",
                  "critic_W1", "critic_b1", "critic_W2", "critic_b2"]
    for cat in categories:
        data[cat] = {}  # initialize as dict; singular values will override later
    try:
        with open(filename, newline='') as csvfile:
            reader = csv.DictReader(csvfile)
            for row in reader:
                cat = row["Category"]
                if cat not in data:
                    data[cat] = {}
                val_str = row.get("Value")
                # Skip if value is missing or empty
                if not val_str:
                    continue
                try:
                    val = float(val_str)
                except (ValueError, TypeError):
                    continue
                idx1 = row["Index1"]
                idx2 = row["Index2"]
                # If both indices are empty, store as a singular value.
                if idx1 == "" and idx2 == "":
                    data[cat] = val
                # If only one index is given, store by that index.
                elif idx2 == "":
                    try:
                        i = int(idx1)
                    except:
                        continue
                    data[cat][i] = val
                else:
                    try:
                        i = int(idx1)
                        j = int(idx2)
                    except:
                        continue
                    data[cat][(i, j)] = val
    except FileNotFoundError:
        return None
    return data

# --- Convert weight dictionaries to list-of-tuples for visualization ---
def get_matrix(matrix_dict):
    """
    Converts a dictionary of weight values (with keys (i,j)) into a list of tuples:
      (source_index, target_index, weight)
    Here, we assume that in the CSV, Index1 corresponds to the target and Index2 to the source.
    We swap them so that connections are drawn left-to-right.
    """
    matrix = []
    for (i, j), weight in matrix_dict.items():
        matrix.append((j, i, weight))
    return matrix

# --- Drawing network diagrams ---
def draw_network(ax, input_data, weight1, weight2, title, output_size):
    """
    Draws a three-layer network diagram on the given Axes:
      - Left column: Input nodes (colored by value)
      - Middle: Hidden nodes (default color)
      - Right: Output nodes (default color)
    weight1: connections from Input to Hidden (list of (source, target, weight))
    weight2: connections from Hidden to Output (list of (source, target, weight))
    """
    ax.clear()
    ax.set_title(title, fontsize=14)
    ax.axis("off")
    
    # Compute node positions:
    input_positions  = [(0, y) for y in np.linspace(1, -1, NUM_INPUTS)]
    hidden_positions = [(1, y) for y in np.linspace(1, -1, HIDDEN_SIZE)]
    output_positions = [(2, y) for y in np.linspace(1, -1, output_size)]
    
    # Draw input nodes (color intensity reflects value using the viridis colormap)
    if len(input_data) > 0:
        input_vals = np.array(input_data)
        norm_input = (input_vals - np.min(input_vals)) / (np.ptp(input_vals) + 1e-6)
    else:
        norm_input = np.zeros(NUM_INPUTS)
    for i, pos in enumerate(input_positions):
        color = plt.cm.viridis(norm_input[i])
        ax.scatter(pos[0], pos[1], s=100, color=color, zorder=3)
    
    # Draw hidden and output nodes with fixed colors.
    for pos in hidden_positions:
        ax.scatter(pos[0], pos[1], s=100, color="lightblue", zorder=3)
    for pos in output_positions:
        ax.scatter(pos[0], pos[1], s=100, color="orange", zorder=3)
    
    # Use the jet colormap for edges.
    cmap = plt.get_cmap("jet")
    
    # Draw edges from Input to Hidden (weight1)
    weights1 = [abs(w) for (_, _, w) in weight1]
    max_w1 = max(weights1) if weights1 else 1.0
    for (src, tgt, w) in weight1:
        if src < NUM_INPUTS and tgt < HIDDEN_SIZE:
            start = input_positions[src]
            end = hidden_positions[tgt]
            norm_val = (w + max_w1) / (2 * max_w1)  # normalized between 0 and 1
            color = cmap(norm_val)
            lw = 0.5 + 3 * abs(w) / max_w1
            ax.plot([start[0], end[0]], [start[1], end[1]], color=color, linewidth=lw, zorder=1)
    
    # Draw edges from Hidden to Output (weight2)
    weights2 = [abs(w) for (_, _, w) in weight2]
    max_w2 = max(weights2) if weights2 else 1.0
    for (src, tgt, w) in weight2:
        if src < HIDDEN_SIZE and tgt < output_size:
            start = hidden_positions[src]
            end = output_positions[tgt]
            norm_val = (w + max_w2) / (2 * max_w2)
            color = cmap(norm_val)
            lw = 0.5 + 3 * abs(w) / max_w2
            ax.plot([start[0], end[0]], [start[1], end[1]], color=color, linewidth=lw, zorder=1)
    
    ax.set_xlim(-0.5, 2.5)
    ax.set_ylim(-1.5, 1.5)

# --- Drawing text information ---
def draw_text_info(ax, info_dict, title):
    """
    Displays key-value pairs from info_dict as text on the given Axes.
    """
    ax.clear()
    ax.set_title(title)
    lines = []
    for key, value in info_dict.items():
        if isinstance(value, float):
            lines.append(f"{key}: {value:.4f}")
        else:
            lines.append(f"{key}: {value}")
    ax.text(0.05, 0.5, "\n".join(lines), transform=ax.transAxes, fontsize=12,
            verticalalignment='center')
    ax.axis("off")

# --- Drawing bar charts for 1D data (for Actor outputs) ---
def draw_actor_output(ax, actor_z2, policy):
    """
    Draw a grouped bar chart for actor outputs (raw outputs and policy probabilities).
    """
    ax.clear()
    ax.set_title("Actor Outputs & Policy")
    if actor_z2 and policy:
        indices = sorted(actor_z2.keys())
        z2_vals = [actor_z2[i] for i in indices]
        policy_vals = [policy[i] for i in indices]
        width = 0.35
        ax.bar([x - width/2 for x in indices], z2_vals, width,
               label="Actor_z2", color="skyblue")
        ax.bar([x + width/2 for x in indices], policy_vals, width,
               label="Policy", color="salmon")
        ax.set_xlabel("Output Index")
        ax.set_ylabel("Value")
        ax.legend()
    else:
        ax.text(0.5, 0.5, "No Actor Output Data", ha="center", va="center")

# --- Animation update function ---
def update(frame):
    filename = "network_parameters.csv"
    data = read_csv_data(filename)
    if data is None:
        return

    # --- Extract values for visualization ---
    # Input vector (shared by both networks)
    input_data = [data["Input"].get(i, 0) for i in range(NUM_INPUTS)]
    
    # Actor network intermediate values (as dictionaries indexed by neuron)
    actor_z2  = data["Actor_z2"]
    policy    = data["Policy"]
    chosen_action = data["Chosen_Action"] if isinstance(data["Chosen_Action"], float) else None
    entropy   = data["Entropy"] if isinstance(data["Entropy"], float) else None
    
    # Critic network intermediate values
    critic_value = data["Critic_Value"] if isinstance(data["Critic_Value"], float) else None
    
    # Learning metrics
    reward    = data["Reward"] if isinstance(data["Reward"], float) else None
    td_error  = data["TD_Error"] if isinstance(data["TD_Error"], float) else None
    advantage = data["Advantage"] if isinstance(data["Advantage"], float) else None

    # Weight matrices (for network diagrams)
    actor_W1 = get_matrix(data["actor_W1"])
    actor_W2 = get_matrix(data["actor_W2"])
    critic_W1 = get_matrix(data["critic_W1"])
    critic_W2 = get_matrix(data["critic_W2"])
    
    # --- Update subplots ---
    # Top row: Network diagrams
    draw_network(ax_actor_net, input_data, actor_W1, actor_W2, "Actor Network", ACTOR_OUTPUTS)
    draw_network(ax_critic_net, input_data, critic_W1, critic_W2, "Critic Network", CRITIC_OUTPUTS)
    
    # Second row, left: Actor outputs (raw and policy)
    draw_actor_output(ax_actor_out, actor_z2, policy)
    
    # Second row, right: Actor info (Chosen Action and Entropy)
    actor_info = {}
    if chosen_action is not None:
        actor_info["Chosen Action"] = int(chosen_action)
    if entropy is not None:
        actor_info["Entropy"] = entropy
    draw_text_info(ax_actor_info, actor_info, "Actor Info")
    
    # Third row (spanning both columns): Critic & Learning metrics.
    critic_info = {}
    if critic_value is not None:
        critic_info["Critic Value"] = critic_value
    if reward is not None:
        critic_info["Reward"] = reward
    if td_error is not None:
        critic_info["TD Error"] = td_error
    if advantage is not None:
        critic_info["Advantage"] = advantage
    draw_text_info(ax_critic_info, critic_info, "Critic & Learning Metrics")

# --- Create figure and layout using GridSpec ---
fig = plt.figure(figsize=(14, 12))
# GridSpec with 3 rows and 2 columns:
#   Row 0: Actor network (left), Critic network (right)
#   Row 1: Actor outputs (left), Actor info (right)
#   Row 2: Critic & learning metrics (span both columns)
gs = gridspec.GridSpec(3, 2, height_ratios=[2, 1, 1])

ax_actor_net   = fig.add_subplot(gs[0, 0])
ax_critic_net  = fig.add_subplot(gs[0, 1])
ax_actor_out   = fig.add_subplot(gs[1, 0])
ax_actor_info  = fig.add_subplot(gs[1, 1])
ax_critic_info = fig.add_subplot(gs[2, :])

plt.tight_layout()

# --- Set up animation (updates every 2 seconds), disabling frame cache to avoid warnings ---
ani = FuncAnimation(fig, update, interval=2000, cache_frame_data=False)

plt.show()
